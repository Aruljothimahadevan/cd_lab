%{
#include "parser.tab.h" // Include the header file generated by Bison
%}
/* Definitions for tokens and patterns */
DIGIT [0-9]    // A single digit
WS [ \t\n]     // Whitespace characters (space, tab, newline)
%%
/* Match one or more digits */
{DIGIT}+ {
    yylval.num = atoi(yytext); // Convert the matched text to an integer
    return NUM; // Return the NUM token to the parser
}
/* Skip whitespace characters */
{WS} /* Skip whitespace */
/* Match any other character (ignored) */
. {}
%%

%{
#include <stdio.h> // For standard I/O functions
extern int yylex(); // Function prototype for the lexer
void yyerror(const char* s); // Error reporting function prototype
int temp_count = 0; // Variable to keep track of temporary registers
%}
/* Declare tokens */
%token NUM
/* Declare operator precedence (lowest precedence first) */
%left '+' '-' // '+' and '-' have the same precedence
%left '*' '/' // '*' and '/' have the same precedence

%%
/* Grammar rules */
program:
    expr { 
        printf("%d\n", $1); // Print the final result of the expression
    }
    ;
expr:
    expr '+' expr {
        $$ = $1 + $3; // Perform addition and store the result in $$
        printf("ADD t%d, t%d, t%d\n", ++temp_count, $1, $3); // Generate intermediate code
    }
    | expr '*' expr {
        $$ = $1 * $3; // Perform multiplication and store the result in $$
        printf("MUL t%d, t%d, t%d\n", ++temp_count, $1, $3); // Generate intermediate code
    }
    | NUM {
        $$ = $1; // Pass the number directly
        printf("t%d = %d\n", ++temp_count, $1); // Generate code for loading a number
    }
    ;
%%
/* Main function */
int main() {
    yyparse(); // Start parsing
    return 0;
}
/* Error handling function */
void yyerror(const char* s) {
    fprintf(stderr, "Error: %s\n", s); // Print the error message to standard error
}
